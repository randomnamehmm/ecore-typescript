import { EcoreEList } from "./EcoreEList";
import { Collection } from "./Collection";
import { InternalEObject } from "./InternalEObject";
import { ArrayList } from "./ArrayList";
import { NotificationChain } from "./NotificationChain";
import { NotificationImpl } from "./NotificationImpl";
import { EStructuralFeature } from "./EStructuralFeature";
import { EReference } from "./EReference";
import { Notification } from "./Notification";
export declare class AbstractCollection<T> extends ArrayList<T> implements EcoreEList<T>, Collection<T> {
    static EOPPOSITE_FEATURE_BASE: number;
    protected static NO_FEATURE: number;
    private owner;
    private featureId;
    private oppositeFeatureId;
    constructor(owner?: InternalEObject, featureId?: number, oppositeFeatureId?: number);
    protected createNotification: (eventType: number, oldValue: any, newValue: any, index: number, wasSet: boolean) => NotificationImpl;
    protected isUnique: () => boolean;
    add: (element: T) => boolean;
    addAll: (collection: T[]) => boolean;
    remove: (item: T) => boolean;
    remove_: (element: T) => T;
    isNotificationRequired: () => boolean;
    basicAdd: (element: T, notifications: NotificationChain) => NotificationChain;
    basicRemove: (element: T, notifications: NotificationChain) => NotificationChain;
    inverseAdd: (element: T, notifications: NotificationChain) => NotificationChain;
    inverseRemove: (element: T, notifications: NotificationChain) => NotificationChain;
    hasNavigableInverse: () => boolean;
    hasInstanceClass: () => boolean;
    hasInverse: () => boolean;
    getEStructuralFeature: () => EStructuralFeature;
    getInverseEReference: () => EReference;
    getInverseFeatureClass: () => Function;
    dispatchNotification: (notification: Notification) => void;
    addUnique: (element: T) => void;
    sortedBy: <T2>(lambda: (T: any) => T2) => void;
    equals: (c: Collection<T>) => boolean;
    notEquals: (c: Collection<T>) => boolean;
    size: () => number;
    includes___: (element: T) => boolean;
    excludes: (element: T) => boolean;
    count: (element: T) => number;
    includesAll: (c: Collection<T>) => boolean;
    excludesAll: (c: Collection<T>) => boolean;
    isEmpty: () => boolean;
    notEmpty: () => boolean;
    max: () => T;
    min: () => T;
    sum: () => T;
    any: (lambda: (element: T) => boolean) => T;
    exists: (lambda: (element: T) => boolean) => boolean;
    forAll: (lambda: (element: T) => boolean) => boolean;
}
